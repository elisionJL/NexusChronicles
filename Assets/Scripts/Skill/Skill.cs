using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "New SKill", menuName = "Skill")]
public class Skill : ScriptableObject
{
    public enum TYPE
    {
        OFFENSIVE,
        TAUNT,
        SUPPORT,
        DEBUFF
    }
    public enum TARGETTING
    {
        SELF,
        SINGLE,
        AOE
    }
    enum CONDITIONALS
    {
        INFRONT,BEHIND,SIDES
    }
    [Tooltip("Name of the skill")]
    [SerializeField] string skillName;
    [Tooltip("Skill Description, will appear in skill UI")]
    [TextArea,SerializeField] string description;
    [Tooltip("The multiplier applied onto the atk: 0.5 = 50% extra dmg")]
    [SerializeField] float dmgMultiplier = 0.5f;
    public bool cooldownUsingTime = false;
    [Tooltip("The Cooldown in time recorded in seconds, if cooldown is not using time, setting this to 3 will reset cooldown after 3 attacks")]
    [SerializeField] float timeCooldown = 1;
    [Tooltip("The type of skill this is e.g(offensive or defensive)")]
    [SerializeField] TYPE skillType = TYPE.OFFENSIVE;
    [Tooltip("What does the skill target?")]
    [SerializeField] TARGETTING skillTargetting = TARGETTING.SINGLE;
    [Tooltip("Does this skill have a conditional?")]
    [SerializeField] bool conditional = false;
    [SerializeField] CONDITIONALS conditionalType = CONDITIONALS.INFRONT;
    [Tooltip("Same As dmgMultiplier but is added on when conitional is met")]
    [SerializeField] float conitionalBonus = 0.5f;
    [Tooltip("The prefab of the skill particle that should be played")]
    [SerializeField] GameObject skillParticleGameObject;
    [Tooltip("whether the skill heals or not. Set to false on default")]
    [SerializeField] bool isHealing = false;
    [Tooltip("the aggro generated by this skill")]
    [SerializeField] float aggroGen = 10;

    public float GetTimer()
    {
        return timeCooldown;
    }
    public TARGETTING GetSkillTargetting()
    {
        return skillTargetting;
    }
    public TYPE GetSkillType()
    {
        return skillType;
    }
    public string GetDescription()
    {
        return description;
    }
    public void UseSkillSingle(float atk, EnemyData eTarget,CharacterData cTarget,Transform characterTrans,ParticleSystem particle)
    {
        float finalMultiplier = 1;
        switch (skillType)
        {
            case TYPE.OFFENSIVE:
                finalMultiplier = 1;
                finalMultiplier += dmgMultiplier;
                if (CheckConditional(eTarget, characterTrans))
                {
                    finalMultiplier += conitionalBonus;
                }
                eTarget.loseHp(atk * finalMultiplier);
                particle.Play();
                CombatManager.instance.ChangeAggro(cTarget.transform, aggroGen);
                break;
            case TYPE.TAUNT:
                particle.Play();
                CombatManager.instance.ChangeAggro(cTarget.transform, aggroGen);
                break;
            case TYPE.SUPPORT:
                if (isHealing)
                {
                    for (int i = 0; i < 4; i++)
                    {
                        CharacterData cData = PartyManager.instance.memberRef[PartyManager.instance.partyMembers[i]].characterData;
                        cData.GainHealth(atk * dmgMultiplier);
                    }
                }
                particle.Play();
                CombatManager.instance.ChangeAggro(cTarget.transform, aggroGen);
                break;
            default:

                break;

        }
    }
    public void UseSkillAOE(float atk, EnemyData eTarget, CharacterData cTarget, Transform characterTrans, ParticleSystem particle,float range)
    {
        float finalMultiplier = 1;
        switch (skillType)
        {
            case TYPE.OFFENSIVE:
                finalMultiplier = 1;
                finalMultiplier += dmgMultiplier;
                if (CheckConditional(eTarget, characterTrans))
                {
                    finalMultiplier += conitionalBonus;
                }
                Collider[] hits;
                hits = Physics.OverlapSphere(eTarget.GetPos(), range, LayerMask.GetMask("Environment"));
                for(int i = 0; i < hits.Length; i++)
                {
                    if (hits[i].CompareTag("Enemy"))
                    {
                        //CombatManager.instance.enemiesInRangeOfPlayer[];
                        eTarget.loseHp(atk * finalMultiplier);
                    }
                }
                
                particle.Play();
                break;
            default:
                break;

        }
    }
    //call when scene starts
    public ParticleSystem CreateParticle(Transform character)
    {
        GameObject particle = Instantiate(skillParticleGameObject);
        particle.transform.SetParent(character);
        particle.transform.localPosition = Vector3.zero;
        return particle.GetComponent<ParticleSystem>();
    }
    bool CheckConditional(EnemyData enemy,Transform characterTrans)
    {
        if (conditional)
        {
            float dotValue = 0;
            if(conditionalType <= CONDITIONALS.SIDES)
            {
                Vector3 direction = (enemy.GetPos() - characterTrans.position).normalized;
                direction.y = 0;
                Vector3 playerForward = characterTrans.forward;
                playerForward.y = 0;
                dotValue = Vector3.Dot(playerForward, direction);
            }
            switch (conditionalType)
            {
                case CONDITIONALS.INFRONT:
                    if (dotValue < -0.5)
                        return true;
                    break;
                case CONDITIONALS.BEHIND:
                    if (dotValue > 0.5)
                        return true;
                    break;
                case CONDITIONALS.SIDES:
                    if (dotValue < 0.5 && dotValue > -0.5)
                        return true;
                    break;
            }
        }
        return false;
    }
    
}
